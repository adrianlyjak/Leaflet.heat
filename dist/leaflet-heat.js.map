{"version":3,"sources":["src/simpleheat.js","src/HeatLayer.js"],"names":["simpleheat","canvas","this","_canvas","document","getElementById","_ctx","getContext","_width","width","_height","height","_sorted","_options","defaultOptions","_data","gray","v","module","exports","prototype","data","add","point","push","clear","setOptions","options","Object","assign","_circles","_grad","getOptions","resize","_initializeCircleBrush","r2","_r","radius","blur","_circle","_createCanvas","ctx","shadowOffsetX","shadowOffsetY","fillStyle","shadowColor","shadowBlur","beginPath","arc","Math","PI","closePath","fill","_initializeGradient","gradient","createLinearGradient","i","addColorStop","fillRect","getImageData","_reinitializeShadowCanvases","_positiveCanvas","_negativeCanvas","_positiveCtx","_negativeCtx","_sortData","valueOfDataPoint","a","self","sort","b","_clearCanvas","c","clearRect","_clearCanvases","draw","minOpacity","p","len","length","weight","alpha","max","undefined","globalAlpha","drawImage","positive","negative","_applyNegativeToPositive","_colorize","putImageData","base","posAlpha","negAlpha","posVal","negVal","posPercent","negPercent","mergedPercent","mergedAlpha","round","totalAlphaPercent","ratioPos","mergedVal","pixels","colorize","grayscale","alphaBurn","missingAlpha","keepRatio","offset","j","floor","createElement","constructor","0.0","0.33","0.5","0.66","1.0","L","SentimentHeatLayer","Layer","Class","extend","initialize","latlngs","_latlngs","_autoMax","setLatLngs","redraw","addLatLng","latlng","_heat","_updateOptions","_frame","_map","_animating","Util","requestAnimFrame","_redraw","onAdd","map","_initCanvas","pane","getPane","appendChild","_panes","overlayPane","on","_reset","zoomAnimation","Browser","any3d","_animateZoom","onRemove","removeChild","getPanes","off","addTo","addLayer","DomUtil","create","originProp","testProp","style","size","getSize","x","y","animated","addClass","topLeft","containerPointToLayerPoint","setPosition","cell","len2","k","layer","r","bounds","Bounds","maxZoom","getMaxZoom","pow","min","getZoom","cellSize","grid","panePos","_getMapPanePos","offsetX","offsetY","ll","latLngToContainerPoint","slice","contains","alt","autoMax","len3","e","scale","getZoomScale","zoom","_getCenterOffset","center","_multiplyBy","subtract","setTransform","TRANSFORM","getTranslateString","sentimentHeatLayer"],"mappings":"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","file":"dist/leaflet-heat.js","sourcesContent":["'use strict';\n\n\nif (typeof module !== 'undefined') module.exports = simpleheat;\n\nfunction simpleheat(canvas) {\n    if (!(this instanceof simpleheat)) return new simpleheat(canvas);\n\n    this._canvas = canvas = typeof canvas === 'string' ? document.getElementById(canvas) : canvas;\n\n    this._ctx = canvas.getContext('2d');\n    this._width = canvas.width;\n    this._height = canvas.height;\n    this._sorted = false;\n    this._options = simpleheat.defaultOptions\n    this._data = [];\n}\n\nsimpleheat.prototype = {\n\n    data: function (data) {\n        this._data = data;\n        this._sorted = false;\n        return this;\n    },\n\n\n    add: function (point) {\n        this._data.push(point);\n        this._sorted = false;\n        return this;\n    },\n\n    clear: function () {\n        this._data = [];\n        return this;\n    },\n\n    setOptions: function (options) {\n        this._options = Object.assign({}, this._options, options);\n        delete this._circles;\n        delete this._grad;\n        return this;\n    },\n\n    getOptions: function () {\n        return Object.assign({}, this._options);\n    },\n\n    resize: function () {\n        this._width = this._canvas.width;\n        this._height = this._canvas.height;\n    },\n\n\n    _initializeCircleBrush: function () {\n\n        var r2 = this._r = this._options.radius + this._options.blur;\n\n        var canvas = this._circle = this._createCanvas();\n        var ctx = canvas.getContext('2d');\n\n        canvas.width = canvas.height = r2 * 2;\n\n        ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;\n        ctx.fillStyle = 'black'\n        ctx.shadowColor = 'black';\n        ctx.shadowBlur = this._options.blur;\n\n\n        ctx.beginPath();\n        ctx.arc(-r2, -r2, this._options.radius, 0, Math.PI * 2, true);\n        ctx.closePath();\n        ctx.fill();\n\n\n    },\n\n    _initializeGradient: function () {\n        // create a 256x1 gradient that we'll use to turn a grayscale heatmap into a colored one\n        var canvas = this._createCanvas(),\n            ctx = canvas.getContext('2d'),\n            gradient = ctx.createLinearGradient(0, 0, 0, 256);\n\n        canvas.width = 1;\n        canvas.height = 256;\n\n        for (var i in this._options.gradient) {\n            gradient.addColorStop(+i, this._options.gradient[i]);\n        }\n\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, 1, 256);\n\n        this._grad = ctx.getImageData(0, 0, 1, 256).data;\n\n        return this;\n    },\n\n    _reinitializeShadowCanvases: function () {\n        if (!this._positiveCanvas) this._positiveCanvas = this._createCanvas();\n        if (!this._negativeCanvas) this._negativeCanvas = this._createCanvas();\n        if (!this._positiveCtx) this._positiveCtx = this._positiveCanvas.getContext('2d');\n        if (!this._negativeCtx) this._negativeCtx = this._negativeCanvas.getContext('2d');\n        this._positiveCanvas.width = this._width;\n        this._negativeCanvas.width = this._width;\n        this._positiveCanvas.height = this._height;\n        this._negativeCanvas.height = this._height;\n    },\n\n    _sortData: function () {\n        var self = this;\n        // sort so that positive is painted over neutra is painted over negative. Unfortunately there does not seem to be\n        // a globalCompositeOperation that treats source layers equally to the layer on the canvas.\n        // Layer color painted last will be stronger\n        function valueOfDataPoint(a) {\n            return a[3] + (a[0] / self._height / 4) + (a[1] / self._width / 4);\n        }\n        this._data.sort(function (a, b) {\n            return valueOfDataPoint(a) - valueOfDataPoint(b)\n        });\n        this._sorted = true;\n    },\n\n    _clearCanvas: function (c) {\n        c.clearRect(0, 0, this._width, this._height);\n    },\n\n    _clearCanvases: function () {\n        this._clearCanvas(this._positiveCtx);\n        this._clearCanvas(this._negativeCtx);\n        this._clearCanvas(this._ctx);\n    },\n\n\n    draw: function (minOpacity) {\n        if (!this._circle) this._initializeCircleBrush();\n        if (!this._grad) this._initializeGradient();\n        if (!this._sorted) this._sortData();\n\n        this._reinitializeShadowCanvases();\n        this._clearCanvases()\n\n        // draw circles according to points on a positive or negative canvas\n        for (var i = 0, len = this._data.length, p; i < len; i++) {\n            p = this._data[i];\n            var weight = p[3] === 0 ? 0.5 : 1;\n            var alpha = Math.max(p[2] * weight / this._options.max, minOpacity === undefined ? 0.05 : minOpacity);\n            if (p[3] >= 0) {\n               this._positiveCtx.globalAlpha = alpha;\n               this._positiveCtx.drawImage(this._circle, p[0] - this._r, p[1] - this._r);\n            }\n\n            if (p[3] <= 0) {\n                this._negativeCtx.globalAlpha = alpha;\n                this._negativeCtx.drawImage(this._circle, p[0] - this._r, p[1] - this._r);\n            }\n        }\n\n        // merge positive and negative into one grayscale image\n        var positive = this._positiveCtx.getImageData(0, 0, this._width, this._height);\n        var negative = this._negativeCtx.getImageData(0, 0, this._width, this._height)\n        this._applyNegativeToPositive(\n            positive.data,\n            negative.data\n        )\n\n        // colorize the heatmap, using opacity value of each pixel to get the right color from our gradient\n        this._colorize(positive.data, this._grad);\n        this._ctx.putImageData(positive, 0, 0);\n        return this;\n\n    },\n\n    _applyNegativeToPositive: function (positive, negative) {\n        // merge the values and opacities of the negative and positive layers into a grayscale image\n        var base = positive;\n        for (var i = 0, len = base.length; i < len; i += 4) {\n            var posAlpha = positive[i + 3],\n                negAlpha = negative[i + 3],\n                posVal = 255 - positive[i],\n                negVal = negative[i];\n\n            if (posAlpha && negAlpha) {\n                var posPercent = posAlpha / 255;\n                var negPercent = negAlpha / 255;\n                var mergedPercent = posPercent + (1 - posPercent) * negPercent; // e.g. 0.5 transparancy + 0.5 transparancy = 0.75 transparency\n                var mergedAlpha = Math.round(mergedPercent * 255);\n                var totalAlphaPercent = posPercent + negPercent;\n                // negative value is always 0, so just merge by multiply positive\n                var ratioPos = posPercent / totalAlphaPercent;\n                var mergedVal = Math.round(255 * ratioPos);\n\n                base[i] = mergedVal,\n                    base[i + 1] = mergedVal,\n                    base[i + 2] = mergedVal,\n                    base[i + 3] = mergedAlpha;\n            } else if (posAlpha) {\n                base[i] = posVal,\n                base[i + 1] = posVal,\n                base[i + 2] = posVal,\n                base[i + 3] = posAlpha;\n\n            } else if (negAlpha) {\n                base[i] = negVal,\n                base[i + 1] = negVal,\n                base[i + 2] = negVal,\n                base[i + 3] = negAlpha;\n            }\n        }\n    },\n\n    _colorize: function (pixels, gradient) {\n        if (this._options.colorize) {\n            for (var i = 0, len = pixels.length; i < len; i += 4) {\n                var alpha = pixels[i + 3] / 256;\n\n                if (alpha) {\n                    var grayscale = pixels[i] // get gradient color from red value, (e.g. grayscale value)\n                    if (this._options.alphaBurn > 0) {\n                        var missingAlpha = (1 - alpha) * this._options.alphaBurn\n                        var keepRatio = 1 - missingAlpha\n                        // burn the gradient value towards the center of the gradient as the alpha is closer to 0\n                        if (grayscale > 127) {\n                            var offset = grayscale - 127\n                            grayscale = Math.round(127 + (offset * keepRatio))\n                        } else {\n                            var offset = 127 - grayscale\n                            grayscale = Math.round(127 - (offset * keepRatio))\n                        }\n                    }\n                    var j = grayscale * 4;\n                    pixels[i] = gradient[j];\n                    pixels[i + 1] = gradient[j + 1];\n                    pixels[i + 2] = gradient[j + 2];\n                    pixels[i + 3] = Math.floor((gradient[j + 3] / 256) * (alpha) * 256);\n                }\n            }\n        }\n    },\n\n    _createCanvas: function () {\n        if (typeof document !== 'undefined') {\n            return document.createElement('canvas');\n        } else {\n            // create a new canvas instance in node.js\n            // the canvas class needs to have a default constructor without any parameter\n            return new this._canvas.constructor();\n        }\n    }\n};\n\nfunction gray(v) {\n    return 'rgb(' + v + ', ' + v + ', ' + v + ')';\n}\n\nsimpleheat.defaultOptions = {\n    alphaBurn: 1,\n    max: 1,\n    radius: 25,\n    blur: 25,\n    gradient: {\n        '0.0': 'rgba(204, 0, 0, 1)',\n        '0.33': 'rgba(255, 178, 0, 1)',\n        '0.5': 'rgba(255, 255, 0, 1)',\n        '0.66': 'rgba(180, 255, 0, 1)',\n        '1.0': 'rgba(0, 214, 96, 1)'\n    },\n    colorize: true\n}\n","'use strict';\n\nL.SentimentHeatLayer = (L.Layer ? L.Layer : L.Class).extend({\n\n    initialize: function (latlngs, options) {\n        this._latlngs = latlngs;\n        this._autoMax = undefined;\n        L.setOptions(this, Object.assign({}, simpleheat.defaultOptions, options));\n    },\n\n    setLatLngs: function (latlngs) {\n        this._latlngs = latlngs;\n        return this.redraw();\n    },\n\n    addLatLng: function (latlng) {\n        this._latlngs.push(latlng);\n        return this.redraw();\n    },\n\n    setOptions: function (options) {\n        L.setOptions(this, options);\n        if (this._heat) this._updateOptions();\n        return this.redraw();\n    },\n\n    redraw: function () {\n        if (this._heat && !this._frame && this._map && !this._map._animating) {\n            this._frame = L.Util.requestAnimFrame(this._redraw, this);\n        }\n        return this;\n    },\n\n    onAdd: function (map) {\n        this._map = map;\n\n        if (!this._canvas) {\n            this._initCanvas();\n        }\n\n        if (this.options.pane) {\n            this.getPane().appendChild(this._canvas);\n        } else {\n            map._panes.overlayPane.appendChild(this._canvas);\n        }\n\n        map.on('moveend', this._reset, this);\n\n        if (map.options.zoomAnimation && L.Browser.any3d) {\n            map.on('zoomanim', this._animateZoom, this);\n        }\n\n        this._reset();\n    },\n\n    onRemove: function (map) {\n        if (this.options.pane) {\n            this.getPane().removeChild(this._canvas);\n        } else {\n            map.getPanes().overlayPane.removeChild(this._canvas);\n        }\n\n        map.off('moveend', this._reset, this);\n\n        if (map.options.zoomAnimation) {\n            map.off('zoomanim', this._animateZoom, this);\n        }\n    },\n\n    addTo: function (map) {\n        map.addLayer(this);\n        return this;\n    },\n\n    _initCanvas: function () {\n        var canvas = this._canvas = L.DomUtil.create('canvas', 'leaflet-heatmap-layer leaflet-layer');\n\n        var originProp = L.DomUtil.testProp(['transformOrigin', 'WebkitTransformOrigin', 'msTransformOrigin']);\n        canvas.style[originProp] = '50% 50%';\n\n        var size = this._map.getSize();\n        canvas.width  = size.x;\n        canvas.height = size.y;\n\n        var animated = this._map.options.zoomAnimation && L.Browser.any3d;\n        L.DomUtil.addClass(canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));\n\n        this._heat = simpleheat(canvas);\n        this._updateOptions();\n        this.redraw();\n    },\n\n    _updateOptions: function () {\n        this._heat.setOptions(this.options)\n    },\n\n    _reset: function () {\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\n        L.DomUtil.setPosition(this._canvas, topLeft);\n\n        var size = this._map.getSize();\n\n        if (this._heat._width !== size.x) {\n            this._canvas.width = this._heat._width  = size.x;\n        }\n        if (this._heat._height !== size.y) {\n            this._canvas.height = this._heat._height = size.y;\n        }\n\n        this._redraw();\n    },\n\n    _redraw: function () {\n        if (!this._map) {\n            return;\n        }\n        var data = [],\n            r = this._heat._r,\n            size = this._map.getSize(),\n            bounds = new L.Bounds(\n                L.point([-r, -r]),\n                size.add([r, r])),\n\n            max = this.options.max === undefined ? 1 : this.options.max,\n            maxZoom = this.options.maxZoom === undefined ? this._map.getMaxZoom() : this.options.maxZoom,\n            v = 1 / Math.pow(2, Math.max(0, Math.min(maxZoom - this._map.getZoom(), 12))),\n            cellSize = r / 2,\n            grid = [],\n            panePos = this._map._getMapPanePos(),\n            offsetX = panePos.x % cellSize,\n            offsetY = panePos.y % cellSize,\n            i, len, p, cell, x, y, j, len2, k, layer;\n\n        var max = 1;\n        // console.time('process');\n        for (i = 0, len = this._latlngs.length; i < len; i++) {\n            var ll = this._latlngs[i]\n            p = this._map.latLngToContainerPoint(ll.slice ? ll.slice(0,2) : ll);\n            if (bounds.contains(p)) {\n                x = Math.floor((p.x - offsetX) / cellSize) + 2;\n                y = Math.floor((p.y - offsetY) / cellSize) + 2;\n\n                var alt =\n                    this._latlngs[i].alt !== undefined ? this._latlngs[i].alt :\n                    this._latlngs[i][2] !== undefined ? +this._latlngs[i][2] : 1;\n                layer = (this._latlngs[i][3] === undefined ? 1 : this._latlngs[i][3]) + 1;\n                k = alt * v;\n\n                grid[y] = grid[y] || [];\n                grid[y][x] = grid[y][x] || [];\n                cell = grid[y][x][layer];\n\n                if (!cell) {\n                    grid[y][x][layer] = [p.x, p.y, k, layer];\n                    max = Math.max(max, k)\n                } else {\n                    cell[0] = (cell[0] * cell[2] + p.x * k) / (cell[2] + k); // x\n                    cell[1] = (cell[1] * cell[2] + p.y * k) / (cell[2] + k); // y\n                    cell[2] += k; // cumulated intensity value\n                    max = Math.max(max, cell[2])\n                }\n            }\n        }\n\n        if (this.options.autoMax && this._heat.getOptions().max != max) {\n            this._heat.setOptions({ max: max })\n        }\n\n        for (var i = 0, len = grid.length; i < len; i++) {\n            if (grid[i]) {\n                for (var j = 0, len2 = grid[i].length; j < len2; j++) {\n                    if (grid[i][j]) {\n                        for (var k = 0, len3 = grid[i][j].length; k < len3; k++) {\n                            cell = grid[i][j][k];\n                            if (cell) {\n                                data.push([\n                                    Math.round(cell[0]),\n                                    Math.round(cell[1]),\n                                    Math.min(cell[2], max),\n                                    cell[3] - 1\n                                ]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // console.timeEnd('process');\n        // console.time('draw ' + data.length);\n        this._heat.data(data).draw(this.options.minOpacity);\n        // console.timeEnd('draw ' + data.length);\n\n        this._frame = null;\n    },\n\n    _animateZoom: function (e) {\n        var scale = this._map.getZoomScale(e.zoom),\n            offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());\n\n        if (L.DomUtil.setTransform) {\n            L.DomUtil.setTransform(this._canvas, offset, scale);\n\n        } else {\n            this._canvas.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ')';\n        }\n    }\n});\n\nL.sentimentHeatLayer = function (latlngs, options) {\n    return new L.SentimentHeatLayer(latlngs, options);\n};\n"]}