{"version":3,"sources":["src/simpleheat.js","src/HeatLayer.js"],"names":["simpleheat","canvas","this","_canvas","document","getElementById","_ctx","getContext","_width","width","_height","height","_sorted","_options","defaultOptions","_data","gray","v","module","exports","prototype","data","add","point","push","clear","setOptions","options","Object","assign","_circles","_grad","getOptions","resize","_initializeCircleBrush","r2","_r","radius","blur","_circle","_createCanvas","ctx","shadowOffsetX","shadowOffsetY","fillStyle","shadowColor","shadowBlur","beginPath","arc","Math","PI","closePath","fill","_initializeGradient","gradient","createLinearGradient","i","addColorStop","fillRect","getImageData","_reinitializeShadowCanvases","_positiveCanvas","_negativeCanvas","_positiveCtx","_negativeCtx","_sortData","valueOfDataPoint","a","self","sort","b","_clearCanvas","c","clearRect","_clearCanvases","draw","minOpacity","p","len","length","weight","alpha","max","undefined","globalAlpha","drawImage","positive","negative","_applyNegativeToPositive","_colorize","putImageData","base","posAlpha","negAlpha","posVal","negVal","posPercent","negPercent","mergedPercent","mergedAlpha","round","totalAlphaPercent","ratioPos","mergedVal","pixels","colorize","j","floor","createElement","constructor","0.0","0.33","0.5","0.66","1.0","L","HeatLayer","Layer","Class","extend","initialize","latlngs","_latlngs","setLatLngs","redraw","addLatLng","latlng","_heat","_updateOptions","_frame","_map","_animating","Util","requestAnimFrame","_redraw","onAdd","map","_initCanvas","pane","getPane","appendChild","_panes","overlayPane","on","_reset","zoomAnimation","Browser","any3d","_animateZoom","onRemove","removeChild","getPanes","off","addTo","addLayer","DomUtil","create","originProp","testProp","style","size","getSize","x","y","animated","addClass","topLeft","containerPointToLayerPoint","setPosition","cell","len2","k","layer","r","bounds","Bounds","maxZoom","getMaxZoom","pow","min","getZoom","cellSize","grid","panePos","_getMapPanePos","offsetX","offsetY","latLngToContainerPoint","contains","alt","len3","e","scale","getZoomScale","zoom","offset","_getCenterOffset","center","_multiplyBy","subtract","setTransform","TRANSFORM","getTranslateString","heatLayer"],"mappings":"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","file":"dist/leaflet-heat.js","sourcesContent":["'use strict';\n\n\nif (typeof module !== 'undefined') module.exports = simpleheat;\n\nfunction simpleheat(canvas) {\n    if (!(this instanceof simpleheat)) return new simpleheat(canvas);\n\n    this._canvas = canvas = typeof canvas === 'string' ? document.getElementById(canvas) : canvas;\n\n    this._ctx = canvas.getContext('2d');\n    this._width = canvas.width;\n    this._height = canvas.height;\n    this._sorted = false;\n    this._options = simpleheat.defaultOptions\n    this._data = [];\n}\n\nsimpleheat.prototype = {\n\n    data: function (data) {\n        this._data = data;\n        this._sorted = false;\n        return this;\n    },\n\n\n    add: function (point) {\n        this._data.push(point);\n        this._sorted = false;\n        return this;\n    },\n\n    clear: function () {\n        this._data = [];\n        return this;\n    },\n\n    setOptions: function (options) {\n        this._options = Object.assign({}, this._options, options);\n        delete this._circles;\n        delete this._grad;\n        return this;\n    },\n\n    getOptions: function () {\n        return Object.assign({}, this._options);\n    },\n\n    resize: function () {\n        this._width = this._canvas.width;\n        this._height = this._canvas.height;\n    },\n\n\n    _initializeCircleBrush: function () {\n\n        var r2 = this._r = this._options.radius + this._options.blur;\n\n        var canvas = this._circle = this._createCanvas();\n        var ctx = canvas.getContext('2d');\n\n        canvas.width = canvas.height = r2 * 2;\n\n        ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;\n        ctx.fillStyle = 'black'\n        ctx.shadowColor = 'black';\n        ctx.shadowBlur = this._options.blur;\n\n\n        ctx.beginPath();\n        ctx.arc(-r2, -r2, this._options.radius, 0, Math.PI * 2, true);\n        ctx.closePath();\n        ctx.fill();\n\n\n    },\n\n    _initializeGradient: function () {\n        // create a 256x1 gradient that we'll use to turn a grayscale heatmap into a colored one\n        var canvas = this._createCanvas(),\n            ctx = canvas.getContext('2d'),\n            gradient = ctx.createLinearGradient(0, 0, 0, 256);\n\n        canvas.width = 1;\n        canvas.height = 256;\n\n        for (var i in this._options.gradient) {\n            gradient.addColorStop(+i, this._options.gradient[i]);\n        }\n\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, 1, 256);\n\n        this._grad = ctx.getImageData(0, 0, 1, 256).data;\n\n        return this;\n    },\n\n    _reinitializeShadowCanvases: function () {\n        if (!this._positiveCanvas) this._positiveCanvas = this._createCanvas();\n        if (!this._negativeCanvas) this._negativeCanvas = this._createCanvas();\n        if (!this._positiveCtx) this._positiveCtx = this._positiveCanvas.getContext('2d');\n        if (!this._negativeCtx) this._negativeCtx = this._negativeCanvas.getContext('2d');\n        this._positiveCanvas.width = this._width;\n        this._negativeCanvas.width = this._width;\n        this._positiveCanvas.height = this._height;\n        this._negativeCanvas.height = this._height;\n    },\n\n    _sortData: function () {\n        var self = this;\n        // sort so that positive is painted over neutra is painted over negative. Unfortunately there does not seem to be\n        // a globalCompositeOperation that treats source layers equally to the layer on the canvas.\n        // Layer color painted last will be stronger\n        function valueOfDataPoint(a) {\n            return a[3] + (a[0] / self._height / 4) + (a[1] / self._width / 4);\n        }\n        this._data.sort(function (a, b) {\n            return valueOfDataPoint(a) - valueOfDataPoint(b)\n        });\n        this._sorted = true;\n    },\n\n    _clearCanvas: function (c) {\n        c.clearRect(0, 0, this._width, this._height);\n    },\n\n    _clearCanvases: function () {\n        this._clearCanvas(this._positiveCtx);\n        this._clearCanvas(this._negativeCtx);\n        this._clearCanvas(this._ctx);\n    },\n\n\n    draw: function (minOpacity) {\n        if (!this._circle) this._initializeCircleBrush();\n        if (!this._grad) this._initializeGradient();\n        if (!this._sorted) this._sortData();\n\n        this._reinitializeShadowCanvases();\n        this._clearCanvases()\n\n        // draw circles according to points on a positive or negative canvas\n        for (var i = 0, len = this._data.length, p; i < len; i++) {\n            p = this._data[i];\n            var weight = p[3] === 0 ? 0.5 : 1;\n            var alpha = Math.max(p[2] * weight / this._options.max, minOpacity === undefined ? 0.05 : minOpacity);\n            if (p[3] >= 0) {\n               this._positiveCtx.globalAlpha = alpha;\n               this._positiveCtx.drawImage(this._circle, p[0] - this._r, p[1] - this._r);\n            }\n\n            if (p[3] <= 0) {\n                this._negativeCtx.globalAlpha = alpha;\n                this._negativeCtx.drawImage(this._circle, p[0] - this._r, p[1] - this._r);\n            }\n        }\n\n        // merge positive and negative into one grayscale image\n        var positive = this._positiveCtx.getImageData(0, 0, this._width, this._height);\n        var negative = this._negativeCtx.getImageData(0, 0, this._width, this._height)\n        this._applyNegativeToPositive(\n            positive.data,\n            negative.data\n        )\n\n        // colorize the heatmap, using opacity value of each pixel to get the right color from our gradient\n        this._colorize(positive.data, this._grad);\n        this._ctx.putImageData(positive, 0, 0);\n        return this;\n\n    },\n\n    _applyNegativeToPositive: function (positive, negative) {\n        // merge the values and opacities of the negative and positive layers into a grayscale image\n        var base = positive;\n        for (var i = 0, len = base.length; i < len; i += 4) {\n            var posAlpha = positive[i + 3],\n                negAlpha = negative[i + 3],\n                posVal = 255 - positive[i],\n                negVal = negative[i];\n\n            if (posAlpha && negAlpha) {\n                var posPercent = posAlpha / 255;\n                var negPercent = negAlpha / 255;\n                var mergedPercent = posPercent + (1 - posPercent) * negPercent; // e.g. 0.5 transparancy + 0.5 transparancy = 0.75 transparency\n                var mergedAlpha = Math.round(mergedPercent * 255);\n                var totalAlphaPercent = posPercent + negPercent;\n                // negative value is always 0, so just merge by multiply positive\n                var ratioPos = posPercent / totalAlphaPercent;\n                var mergedVal = Math.round(255 * ratioPos);\n\n                base[i] = mergedVal,\n                    base[i + 1] = mergedVal,\n                    base[i + 2] = mergedVal,\n                    base[i + 3] = mergedAlpha;\n            } else if (posAlpha) {\n                base[i] = posVal,\n                base[i + 1] = posVal,\n                base[i + 2] = posVal,\n                base[i + 3] = posAlpha;\n\n            } else if (negAlpha) {\n                base[i] = negVal,\n                base[i + 1] = negVal,\n                base[i + 2] = negVal,\n                base[i + 3] = negAlpha;\n            }\n        }\n    },\n\n    _colorize: function (pixels, gradient) {\n        if (this._options.colorize) {\n            for (var i = 0, len = pixels.length, j; i < len; i += 4) {\n                var alpha = pixels[i + 3];\n\n                if (alpha) {\n                    j = pixels[i] * 4; // get gradient color from red value, (e.g. grayscale value)\n                    pixels[i] = gradient[j];\n                    pixels[i + 1] = gradient[j + 1];\n                    pixels[i + 2] = gradient[j + 2];\n                    pixels[i + 3] = Math.floor((gradient[j + 3] / 256) * (alpha / 256) * 256);\n                }\n            }\n        }\n    },\n\n    _createCanvas: function () {\n        if (typeof document !== 'undefined') {\n            return document.createElement('canvas');\n        } else {\n            // create a new canvas instance in node.js\n            // the canvas class needs to have a default constructor without any parameter\n            return new this._canvas.constructor();\n        }\n    }\n};\n\nfunction gray(v) {\n    return 'rgb(' + v + ', ' + v + ', ' + v + ')';\n}\n\nsimpleheat.defaultOptions = {\n    max: 1,\n    radius: 25,\n    blur: 25,\n    gradient: {\n        '0.0': 'rgba(204, 0, 0, 1)',\n        '0.33': 'rgba(255, 178, 0, 1)',\n        '0.5': 'rgba(255, 255, 0, 1)',\n        '0.66': 'rgba(180, 255, 0, 1)',\n        '1.0': 'rgba(0, 214, 96, 1)'\n    },\n    colorize: true\n}\n","'use strict';\n\nL.HeatLayer = (L.Layer ? L.Layer : L.Class).extend({\n\n    initialize: function (latlngs, options) {\n        this._latlngs = latlngs;\n        L.setOptions(this, Object.assign({}, simpleheat.defaultOptions, options));\n    },\n\n    setLatLngs: function (latlngs) {\n        this._latlngs = latlngs;\n        return this.redraw();\n    },\n\n    addLatLng: function (latlng) {\n        this._latlngs.push(latlng);\n        return this.redraw();\n    },\n\n    setOptions: function (options) {\n        L.setOptions(this, options);\n        if (this._heat) this._updateOptions();\n        return this.redraw();\n    },\n\n    redraw: function () {\n        if (this._heat && !this._frame && this._map && !this._map._animating) {\n            this._frame = L.Util.requestAnimFrame(this._redraw, this);\n        }\n        return this;\n    },\n\n    onAdd: function (map) {\n        this._map = map;\n\n        if (!this._canvas) {\n            this._initCanvas();\n        }\n\n        if (this.options.pane) {\n            this.getPane().appendChild(this._canvas);\n        } else {\n            map._panes.overlayPane.appendChild(this._canvas);\n        }\n\n        map.on('moveend', this._reset, this);\n\n        if (map.options.zoomAnimation && L.Browser.any3d) {\n            map.on('zoomanim', this._animateZoom, this);\n        }\n\n        this._reset();\n    },\n\n    onRemove: function (map) {\n        if (this.options.pane) {\n            this.getPane().removeChild(this._canvas);\n        } else {\n            map.getPanes().overlayPane.removeChild(this._canvas);\n        }\n\n        map.off('moveend', this._reset, this);\n\n        if (map.options.zoomAnimation) {\n            map.off('zoomanim', this._animateZoom, this);\n        }\n    },\n\n    addTo: function (map) {\n        map.addLayer(this);\n        return this;\n    },\n\n    _initCanvas: function () {\n        var canvas = this._canvas = L.DomUtil.create('canvas', 'leaflet-heatmap-layer leaflet-layer');\n\n        var originProp = L.DomUtil.testProp(['transformOrigin', 'WebkitTransformOrigin', 'msTransformOrigin']);\n        canvas.style[originProp] = '50% 50%';\n\n        var size = this._map.getSize();\n        canvas.width  = size.x;\n        canvas.height = size.y;\n\n        var animated = this._map.options.zoomAnimation && L.Browser.any3d;\n        L.DomUtil.addClass(canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));\n\n        this._heat = simpleheat(canvas);\n        this._updateOptions();\n        this.redraw();\n    },\n\n    _updateOptions: function () {\n        this._heat.setOptions(this.options)\n    },\n\n    _reset: function () {\n        var topLeft = this._map.containerPointToLayerPoint([0, 0]);\n        L.DomUtil.setPosition(this._canvas, topLeft);\n\n        var size = this._map.getSize();\n\n        if (this._heat._width !== size.x) {\n            this._canvas.width = this._heat._width  = size.x;\n        }\n        if (this._heat._height !== size.y) {\n            this._canvas.height = this._heat._height = size.y;\n        }\n\n        this._redraw();\n    },\n\n    _redraw: function () {\n        if (!this._map) {\n            return;\n        }\n        var data = [],\n            r = this._heat._r,\n            size = this._map.getSize(),\n            bounds = new L.Bounds(\n                L.point([-r, -r]),\n                size.add([r, r])),\n\n            max = this.options.max === undefined ? 1 : this.options.max,\n            maxZoom = this.options.maxZoom === undefined ? this._map.getMaxZoom() : this.options.maxZoom,\n            v = 1 / Math.pow(2, Math.max(0, Math.min(maxZoom - this._map.getZoom(), 12))),\n            cellSize = r / 2,\n            grid = [],\n            panePos = this._map._getMapPanePos(),\n            offsetX = panePos.x % cellSize,\n            offsetY = panePos.y % cellSize,\n            i, len, p, cell, x, y, j, len2, k, layer;\n\n        // console.time('process');\n        for (i = 0, len = this._latlngs.length; i < len; i++) {\n            p = this._map.latLngToContainerPoint(this._latlngs[i]);\n            if (bounds.contains(p)) {\n                x = Math.floor((p.x - offsetX) / cellSize) + 2;\n                y = Math.floor((p.y - offsetY) / cellSize) + 2;\n\n                var alt =\n                    this._latlngs[i].alt !== undefined ? this._latlngs[i].alt :\n                    this._latlngs[i][2] !== undefined ? +this._latlngs[i][2] : 1;\n                layer = (this._latlngs[i][3] === undefined ? 1 : this._latlngs[i][3]) + 1;\n                k = alt * v;\n\n                grid[y] = grid[y] || [];\n                grid[y][x] = grid[y][x] || [];\n                cell = grid[y][x][layer];\n\n                if (!cell) {\n                    grid[y][x][layer] = [p.x, p.y, k, layer];\n\n                } else {\n                    cell[0] = (cell[0] * cell[2] + p.x * k) / (cell[2] + k); // x\n                    cell[1] = (cell[1] * cell[2] + p.y * k) / (cell[2] + k); // y\n                    cell[2] += k; // cumulated intensity value\n                }\n            }\n        }\n\n        for (var i = 0, len = grid.length; i < len; i++) {\n            if (grid[i]) {\n                for (var j = 0, len2 = grid[i].length; j < len2; j++) {\n                    if (grid[i][j]) {\n                        for (var k = 0, len3 = grid[i][j].length; k < len3; k++) {\n                            cell = grid[i][j][k];\n                            if (cell) {\n                                data.push([\n                                    Math.round(cell[0]),\n                                    Math.round(cell[1]),\n                                    Math.min(cell[2], max),\n                                    cell[3] - 1\n                                ]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // console.timeEnd('process');\n        // console.time('draw ' + data.length);\n        this._heat.data(data).draw(this.options.minOpacity);\n        // console.timeEnd('draw ' + data.length);\n\n        this._frame = null;\n    },\n\n    _animateZoom: function (e) {\n        var scale = this._map.getZoomScale(e.zoom),\n            offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());\n\n        if (L.DomUtil.setTransform) {\n            L.DomUtil.setTransform(this._canvas, offset, scale);\n\n        } else {\n            this._canvas.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ')';\n        }\n    }\n});\n\nL.heatLayer = function (latlngs, options) {\n    return new L.HeatLayer(latlngs, options);\n};\n"]}